export const metadata = {
  title: '标签',
  description:
    '用于审核和其他目的的账户或内容的自我认证字符串注解。',
}

# 标签(Labels)

**标签(Labels)** 是 atproto 生态系统中关于任何账户或内容的元数据形式。{{ className: 'lead' }}

标签以独立的、自我认证的数据对象形式存在，但通常也作为 API 响应的一部分进行分发（在这种情况下可能不包含签名）。此外，标签"值"也可以直接嵌入记录本身("自我标签")。{{ className: 'lead' }}

标签主要由来源(DID)、主题(URI)和值组成。值是一个短字符串，类似于标签或话题标签，其语义在标签的创建者和使用者之间预先定义。其他元数据字段可以提供额外的上下文，但在任何时间点，同一个来源、主题和值的组合应该只有一组连贯的元数据。如果存在多组元数据，则使用 `created-at` 时间戳来确定当前有效的标签。{{ className: 'lead' }}

标签概念和协议原语在范围、用例和数据传输方面都具有灵活性。最初的设计动机之一是支持某些形式的可组合审核，通过审核服务生成标签。但标签不仅限于审核用途，可以在 atproto 应用程序中自由用于其他目的。{{ className: 'lead' }}

核心标签模式是版本化的，本文档描述的是标签版本 `1`。{{ className: 'lead' }}

## Schema 和数据模型

标签是协议对象，类似于仓库提交或 MST 节点。它们规范地编码为 DAG-CBOR(CBOR 的严格标准化子集)以进行签名(参见下面的章节)。有一个 Lexicon 定义(`com.atproto.label.defs#label`)用于表示标签，但它的字段要求与核心协议对象略有不同:在该版本中，版本字段(`ver`)和签名(`sig`)都是可选的。

标签对象的字段包括:

- `ver` (整数，必需): 标签模式版本。当前版本始终为 `1`。
- `src` (字符串，DID 格式，必需): 生成此标签的权威(账户)
- `uri` (字符串，URI 格式，必需): 此标签应用的内容。对于特定记录，使用 `at://` URI。对于账户，使用 `did:`。
- `cid` (字符串，CID 格式，可选): 如果提供，则标签应用于主题 `uri` 的特定版本
- `val` (字符串，最大 128 字节，必需): 标签的值。语义和首选语法在下面讨论。
- `neg` (布尔值，可选): 如果为 `true`，表示此标签"否定"具有相同 `src`、`uri` 和 `val` 的早期标签。
- `cts` (字符串，日期时间格式，必需): 创建标签的时间戳。注意，分布式系统中的时间戳默认不可信且未经验证。
- `exp` (字符串，日期时间格式，可选): 此标签过期(不再有效)的时间戳
- `sig` (字节，可选): 加密签名字节。使用[数据模型](/specs/data-model)中的 `bytes` 类型，在 JSON 中编码为带有 base64 编码的 `$bytes` 对象

当标签作为完整对象在服务之间传输时，`ver` 和 `sig` 字段是必需的。

如果 `neg` 字段为 `false`，最佳实践是完全不包含该字段。

使用三字符字段名与 atproto 的大多数部分不同，更接近于 JWT。这种差异的动机是在网络请求和响应中包含许多标签时最小化标签的大小。

## 值

`val` 字段是标签的核心。为了保持协议的灵活性，并允许未来词汇表、规范和治理结构的发展，这里几乎没有指定这个字符串的语义、行为和已知值。

目前预期标签值字符串是具有固定词汇表的"令牌"。它们类似于话题标签。

目前，我们强烈建议*避免*以下模式:

- 在值字段中打包额外的结构。例如，base64 编码数据、键/值语法、值的列表或数组等
- 编码任意数值(例如，"分数"或"置信度")
- 使用标点符号(如 `.`、`:`、`;`、`#`、`_`、`'`、`>` 或其他)来构建标签命名空间
- 在值中使用 URL 或 URI
- 使用任何空白字符
- 使用非 ASCII 字符，包括表情符号

这些都是很有前途的想法，但我们希望更正式地协调和指定这种语法扩展。

当前的一个惯例是使用感叹号标点符号(`!`)作为系统级标签的前缀，这些标签指定了主题的预期行为，但不描述内容或指示行为的原因。例如，`!warn` 是一个行为，而 `scam` 是一个描述性标签，可能会导致相同的警告行为。

标签的行为、定义、含义和政策通常在其他地方传达。值不需要完全具有描述性。


### 推荐的字符串语法

当前推荐的标签字符串语法是使用小写 kebab 语法(内部使用 `-` 连接)，仅使用 ASCII 字母。具体来说：

- 小写 ASCII 字母 (`a` 到 `z`)
- 使用短横线 (`-`) 作为内部分隔符，但不能作为第一个或最后一个字符
- 不允许使用其他标点符号或空白字符
- 最大长度 128 字节。越短越好(尽量保持标签在几十个字符以内)，但同时要保持一定的描述性。

## 标签生命周期：否定和过期

标签通常由接收服务内部广播和持久化。一些服务可能会批量向下游服务重新广播或重新分发标签。它们可以忽略和丢弃任何与其用例无关的标签。它们可能会在客户端请求中"注入(hydrate)"标签。

在注入标签时，服务一般应该只包含"活跃"和相关的标签。

如果标签的权威创建者希望撤回或移除标签，他们可以通过发布一个具有相同来源、主题和值，但将否定字段(`neg`)设置为 true 的新标签来实现，并使用当前时间戳(晚于任何先前的时间戳)。否定标签并不意味着该标签的相反含义为"真"，而只是表示先前的标签应被忽略。例如，一个值为 `spam` 且 `neg` 为 true 的标签并不意味着该主题*不是* spam，而只是表示先前的 `spam` 标签应被忽略。

接收到有效否定标签的服务可以在内部存储否定信息，并可以重新广播否定信息，但不应在 API 响应中注入被否定的标签。

同样，服务可以继续保存过期的标签(在过期时间戳之后)，但不应继续在 API 响应中注入它们。

## 签名

标签使用公钥[密码学](/specs/cryptography)进行签名，类似于仓库提交对象。在服务之间传输标签时应验证签名。假定大多数终端客户端不会自行验证签名，为了网络效率，发送给客户端的 API 响应中可能会删除签名。客户端和其他方应该有一个验证签名的机制，可以通过从标签颁发机构查询单个签名，并收到包含签名的完整标签来实现。

签名或验证签名的过程是构建标签的完整版本，只使用指定的 schema 字段，且不包括 `sig` 字段。这意味着包括 `ver` 字段，但不包括任何 `$type` 字段或在标签的 Lexicon 表示中可能包含的其他未指定字段。然后将此数据对象按照确定性的 IPLD/DAG-CBOR 规范化规则编码为 CBOR。CBOR 字节使用 SHA-256 进行哈希处理，然后使用适当的加密密钥对直接哈希字节(而不是十六进制编码的字符串)进行签名(或验证)。签名字节作为字节存储在 `sig` 字段中(有关表示字节的详细信息，请参见[数据模型](/specs/data-model))。

用于签名标签的密钥可在发行身份的 DID 文档中找到，具有片段标识符 `#atproto_label`。此密钥*可能*与用于仓库签名的 `#atproto` 签名密钥具有相同的值。目前，如果找不到 `#atproto_label` 密钥，实现*不应*尝试使用 DID 文档中存在的其他密钥来验证签名，而应简单地将签名视为无效并忽略该标签。

### 签名生命周期

签名在接收标签时进行验证。在注入到 API 响应之前不需要重新验证。

对于大型标签服务来说，签名密钥轮换可能很困难且具有破坏性。大致的轮换机制是：

- 标签服务应该将签名与标签一起持久化，并同时保存指示用于签名标签的密钥的标识符
- 开始轮换时，暂停创建和签名新标签
- 使用新密钥更新 DID 文档
- 使用新密钥恢复签名新标签
- 当服务旧标签查询时，检查使用了哪个签名密钥。如果过期，重新签名并持久化该批标签的签名。created-at 时间戳不应更改。
- 标签事件流回填期间的较旧标签可能具有无效签名；这是可以接受的

当遇到签名无效的标签时，一个好的做法是重新解析发行者身份(DID 文档)并检查是否有更新的签名密钥。如果有，应该重试验证。

当上游密钥轮换发生时，下游服务可以自行决定是批量查询和接收更新的签名；还是按需获取更新的签名；或者即使签名不再针对当前标签签名密钥进行验证，也认为旧标签仍然有效。

## 记录中的自我标签

一种 Lexicon 设计模式是在记录中包含标签值数组。下游客户端可以将这些解释为"自我标签"，类似于来自外部来源的标签。

请注意，仓库数据存储机制提供了类似于完整标签对象的上下文和生命周期支持：

- 标签的来源是控制仓库的账户
- 主题是记录本身，或可能是整个仓库账户(取决于上下文)
- CID 是记录的当前版本
- 不需要否定和过期，因为可以删除或更新记录以更改标签集
- created-at 时间戳与记录本身相同(例如，通过 `createdAt` 字段)
- 真实性(签名)由仓库提交签名机制提供

## 标签服务身份

每个标签服务都有一个服务身份，即 DID 文档。这是出现在标签源(`src`)字段中的 DID。

DID 文档还将具有用于签名标签的密钥(ID 为 `#atproto_label`；有关签名详细信息，请参见上文)，以及指示服务器 URL 的服务端点(ID 为 `#atproto_labeler` 且类型为 `AtprotoLabeler`)(URL 包括方法、主机名和可选端口，但此时没有路径段)。请注意，在实际使用场景中，强烈建议且服务运营商可能要求在默认端口(443)上使用 HTTPS。

根据应用程序的不同，身份还可能有一个 atproto 仓库，其中包含描述标签器特定于应用程序的上下文的"声明记录"。这可能是与特定应用程序、客户端或 AppView 集成所必需的，但在基本 atproto 层面不是必需的。

## 标签分发端点

为标签服务定义了两个 Lexicon 端点来分发标签：

`com.atproto.label.subscribeLabels`：事件流(WebSocket)端点，用于广播新标签。实现类似于仓库事件流的 `seq` 回填机制，但有一些小的区别：
"回填"期可能延伸到 `cursor=0`(意味着可以通过流获得标签的完整历史记录)。已被删除的标签会从流中删除原始标签，但否定标签仍然保留。

`com.atproto.label.queryLabels`：灵活的查询端点。可用于滚动浏览所有标签(使用游标参数)，或过滤特定主题相关的标签。

请注意，与公共仓库内容不同，标签不*要求*公开可枚举。标签服务可以选择使用这些端点公开所有标签，或要求授权和访问控制，或完全不实现这些端点(如果它们有其他分发标签的机制)。

## Labeler HTTP Headers

标签通常被 atproto 服务(如 AppViews)在 HTTP API 响应中"注入"。为了让客户端控制它们想要包含的标签源，使用了两个特殊的 HTTP 头，PDS 实现在代理请求时需要传递这些头：

`atproto-accept-labelers`：用于请求。标签服务 DID 列表，带有可选的每个 DID 标志。

`atproto-content-labelers`：用于响应。与 `accept` 头具有相同的内容、语法和语义，但表示实际可以查询哪些标签器。出现在此头中并不意味着实际包含了来自给定 DID 的任何标签，只是表示如果存在这样的标签，它们会被包含。

这些头的语法遵循 IETF RFC-8941("HTTP 的结构化字段值")第 3.1.2 节("参数")。值由逗号(ASCII `,` 字符)分隔，重复声明头的值应合并为单个列表。一个或多个可选参数可以跟在项目值(DID)后面，由分号(ASCII `;` 字符)分隔。对于布尔参数，目前不支持完整的 RFC 语法(仅作为 `param=?0` 表示 false)。相反，参数的存在表示它为"true"，不存在表示"false"。目前不支持其他参数值类型(如整数或字符串)。

目前唯一支持的参数是布尔参数 `redact`。此标志表示注入标签的服务应该通过完全从 API 响应中删除内容来处理特殊协议级标签值 `!takedown` 和 `!suspend`，而不是简单地标记它。这可能会产生特定于应用程序的墓碑条目，可能指示负责删除的标签器，或可能导致内容被删除而没有墓碑。

这些头的完整示例语法：



```
# on a request
atproto-accept-labelers: did:web:mod.example.com;redact, did:plc:abc123, did:plc:xyz789

# on a response:
atproto-content-labelers: did:web:mod.example.com;redact, did:plc:abc123, did:plc:xyz789
```

如果请求头的语法无效或无法解析，服务应返回错误而不是忽略该头。

如果标签器 DID 在头中重复出现，应该合并每个实例的参数。例如，如果一个 DID 包含一次带有 `redact` 且一次不带参数，服务应该将其视为该 DID 只包含一次且带有 `redact`。`atproto-content-labelers` 响应头应该体现请求头是如何去重和解释的。

如果完全没有提供请求头，服务可以使用默认值。这与提供没有值的头不同，后者情况下服务不应注入或应用任何标签。

如果任何标签器 DID 使用了正确的语法，但该身份不存在；在 DID 文档中不包含标签器服务或密钥条目；已在服务级别被停用；或者因其他原因处于非活动或无法使用状态；那么该标签器不应包含在 `atproto-content-labelers` 响应头中，但不需要作为错误处理。

服务实现可以根据策略决定必须满足特定条件，否则将返回错误。例如，必须包含特定标签器 DID；或者可以包含的标签器数量有最小值或最大值；或者带有 `redact` 的标签器数量有最小值或最大值。

## 安全考虑

需要注意的是，签名没有"域区分"，这意味着存在潜在的安全风险 - 签名的标签可能在完全不同的上下文中也是一个有效的对象(和签名)，比如认证令牌。因此确保被签名的对象中不包含任何额外或意外字段十分重要。

## 使用和实现指南

目前强烈建议遵循标签值的"推荐字符串语法"。

## 未来可能的变更

关于标签值的更成熟的治理、命名空间和风格指南建议。
