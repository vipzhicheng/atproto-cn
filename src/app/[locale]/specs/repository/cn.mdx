export const metadata = {
  title: 'Repository',
  description:
    '用于公共账户内容的自认证存储',
}

# Repository 仓库

*参见[数据仓库指南](../guides/data-repos)以获取更高层次的介绍。*

atproto 的公共内容(**records** 记录)存储在每个账户的仓库中(通常简称为 **repo**)。所有当前活跃的记录都存储在仓库中,且当前仓库内容是公开可用的,但同时也完全支持内容删除和账户删除。{{ className: 'lead' }}

仓库数据结构是基于内容寻址的([Merkle-tree](https://en.wikipedia.org/wiki/Merkle_tree)),仓库内容的每次变更(例如添加、删除和更新记录)都会产生一个新的 commit `data` 哈希值(CID)。Commits 经过加密签名,签名密钥可以轮换,这允许递归验证部分或全部的内容。{{ className: 'lead' }}

仓库及其内容规范上以二进制 [DAG-CBOR](https://ipld.io/docs/codecs/known/dag-cbor/) 格式存储,作为通过内容哈希(CID Links)相互引用的数据对象图。大型二进制 blob 不直接存储在仓库中,而是通过哈希([CID](https://github.com/multiformats/cid))引用。这包括图片和其他媒体对象。仓库可以导出为 [CAR](https://ipld.io/specs/transport/car/carv1/) 文件用于离线备份、账户迁移或其他目的。{{ className: 'lead' }}

在 atproto 联邦架构中,账户仓库的权威位置是关联的个人数据服务器(Personal Data Server, PDS)。账户当前的 PDS 位置在 DID Document 中权威性地指示。{{ className: 'lead' }}

在实际使用中,预计单个仓库将包含从几十到数百万条记录。{{ className: 'lead' }}


## 仓库数据结构 (v3)

这里描述仓库二进制格式的第 `3` 版。

版本 `2` 有略微不同的 commit 对象模式,但与 `3` 基本兼容。

版本 `1` 有不同的 MST fanout 配置,且 commits 和仓库元数据的模式不兼容。版本 `1` 已弃用,网络中不存在这种格式的仓库,实现也不需要支持它。

从高层次看,一个仓库是一个键值映射,其中键是路径名(字符串),值是记录(DAG-CBOR 对象)。

**Merkle Search Tree** (MST) 用于存储这个映射。这个基于内容寻址的确定性数据结构以键排序方式存储数据。它对于键查找、键范围扫描和追加(假设记录路径是有序的)都相当高效。MST 的一般属性在这篇学术出版物中有描述:

> Alex Auvolat, François Taïani. Merkle Search Trees: Efficient State-Based CRDTs in Open Networks. SRDS 2019 - 38th IEEE International Symposium on Reliable Distributed Systems, Oct 2019, Lyon, France. pp.1-10, ff10.1109/SRDS.2019.00032 ([pdf](https://inria.hal.science/hal-02303490/document))

atproto 仓库中使用的 MST 具体细节如下所述。

仓库路径是字符串,而 MST 键是字节数组。两者都不能为空(零长度)。虽然目前仓库路径字符串限制为 ASCII 子集(使编码成为无操作),但指定的编码是 UTF-8。

仓库路径目前有固定的结构 `<collection>/<record-key>`。这意味着一个有效的、规范化的 [NSID](./nsid),后跟 `/`,再后跟一个有效的 [Record Key](./record-key)。路径不应以前导 `/` 开头,且应始终只有两个路径段。整个路径字符串中当前允许的 ASCII 字符包括:字母(`A-Za-z`)、数字(`0-9`)、斜杠(`/`)、句点(`.`)、连字符(`-`)、下划线(`_`)和波浪号(`~`)。特定的路径段 `.` 和 `..` 不是有效的 NSID 或 Record Key,且在仓库路径中始终不允许使用。

请注意,同一集合中所有记录的仓库路径在 MST 中一起排序,使枚举(通过键扫描)和导出高效。此外,TID Record Key 方案有意选择在集合范围内提供 MST 键的时间排序。相较于树内的随机插入/变更,追加更加高效,且在枚举集合内的记录时,它们将按时间顺序排列(假设 TID 生成正确,但通常不能依赖这一点)。


### Commit 对象

仓库中的顶层数据对象是一个签名的 commit。数据字段包括:

- `did` (字符串,必需):与仓库关联的账户 DID,采用严格规范化形式(例如,适当的小写)
- `version` (整数,必需):对于此仓库格式版本固定值为 `3`
- `data` (CID 链接,必需):指向仓库内容树结构(MST)顶部的指针
- `rev` (字符串,TID 格式,必需):仓库的修订版本,用作逻辑时钟。必须单调递增。建议使用当前时间戳作为 TID;"未来"的 `rev` 值(超过容差时间)应被忽略且不处理。
- `prev` (CID 链接,可为空):指向此仓库前一个 commit 对象的指针(通过哈希)。可用于创建历史链,但很少使用(为 v2 向后兼容性而包含)。在版本 `3` 仓库中,此字段必须存在于 CBOR 对象中,但实际上几乎总是 `null`。注意:之前指定为可为空且可选,但这导致了互操作性问题。
- `sig` (字节数组,必需):此 commit 的加密签名,以原始字节形式

UnsignedCommit 数据对象具有除 `sig` 外的所有相同字段。签名 commit 的过程是填充所有数据字段,然后用 DAG-CBOR 序列化 UnsignedCommit。然后用 SHA-256 对输出字节进行哈希,并使用账户当前的"签名密钥"对二进制哈希输出(无十六进制编码)进行签名。然后将签名作为原始字节与所有其他数据字段一起存储在 commit 对象中。

整个 commit 的 CID 是通过将*已签名的* commit 对象序列化为 DAG-CBOR 生成的。请参见下文关于"blessed" CID 格式的说明,特别要确保对链接到 commit 对象的 CID 使用 `dag-cbor` multicodec。

注意,签名本身和已签名的 commit 既不指示使用的密钥类型(曲线类型),也不指示使用的特定公钥。该信息必须从账户的 DID 文档中获取。通过密钥轮换,较旧 commit 签名的验证可能变得模糊。最新的 commit 应始终可以使用当前的 DID 文档进行验证。这意味着每次轮换签名密钥时都应创建新的仓库 commit。这样的 commit 不需要更新 `data` CID 链接。


### MST 结构

从高层次看,仓库 MST 是一个键值映射,其中键是非空字节数组,值是指向记录的 CID 链接。MST 数据结构应该可以从这种字节串到 CID 的映射完全重建,具有完全可重现的根 CID 哈希(即 commit 对象中的 `data` 字段)。

树结构中的每个节点都包含一组键/CID 映射,以及指向其他子树节点的链接。条目和链接按键排序,链接子树(递归)的所有键都落在对应链接位置的范围内。排序顺序是从**左**(字典序最前)到**右**(字典序最后)。每个键都有一个从键本身派生的**深度**,决定它最终在哪个子树中。树中的顶部节点包含具有最高深度值的所有键(对于小型树可能都是深度为零,因此为单个节点)。节点中整体左侧或右侧的链接,或任意两个键之间的链接,指向包含在相应键范围内的子树节点。

没有记录的空仓库表示为具有空条目数组的单个 MST 节点。这是树中可能包含空叶节点(既不包含键("条目")也不指向包含条目的子树)的唯一情况。树的顶部不能是仅指向子树的空节点。允许空的中间节点,只要它们指向包含条目的子树。换句话说,必须从树的顶部和底部修剪空节点,但必须保留空的中间节点,以使子树链接不跳过深度级别。无论导致当前内容的插入和删除历史如何,MST 的整体结构和形状都是基于当前键/值内容确定的。

### CID 格式

IPFS CID 规范非常灵活,支持多种哈希类型、指示链接内容类型的字段以及各种字符串编码选项。这些功能对于仓库格式的演进很有价值,但为了最大限度地提高实现之间的互操作性,只允许使用特定的"blessed"CID 类型集。

当链接到 commit 对象、MST 节点(即 `data`,或 MST 内部链接)或记录(即指向记录的 MST 叶节点)时,commit 对象和 MST 节点对象的 blessed 格式是:

- CIDv1
- Multibase:DAG-CBOR 内的二进制序列化(或 JSON 映射的 `base32`)
- Multicodec:`dag-cbor` (0x71)
- Multihash:`sha-256`,256 位 (0x12)

在仓库的上下文中,根据内容使整体数据结构可重现也是可取的,因此严格限制和强制允许的 CID 类型。具有不合规 `prev` 或 `data` 链接的 commit 对象被视为无效。具有指向其他 MST Node 对象的不合规链接的 MST Node 对象被视为无效,整个 MST 数据结构也无效。

在处理从 MST 到记录的"叶"链接时允许更大的灵活性,实现应保留这些映射使用的确切 CID 链接,而不是规范化。在生成指向记录的新 CID Links 时,实现应严格遵循 CID blessed 格式。


## CAR 文件序列化

存储数据对象的标准文件格式是内容可寻址存档(Content Addressable aRchives, CAR)。atproto 仓库的标准导出格式是 [CAR v1](https://ipld.io/specs/transport/car/carv1/),其文件后缀为 `.car`,MIME 类型为 `application/vnd.ipld.car`。

CARv1 格式非常简单。它包含一个小型元数据头(可以指示一个或多个"root" CID 链接),然后是一系列二进制"blocks",每个都是一个数据对象。在 atproto 仓库的上下文中:

- CAR `roots` 元数据数组的第一个元素必须是最相关的 Commit 对象的 CID。对于一般导出,这是当前(最新)commit。`roots` 数组中也可能存在其他 CID,具有(暂时)未定义的含义或顺序
- 对于完整导出,必须包含指定 commit 的完整仓库结构,其中包括所有记录和所有 MST 节点
- CAR 文件中块的顺序目前未定义或限制。实现可能有"首选"顺序,但应该容忍意外的顺序
- CAR 文件中可能包含或不包含额外的块,包括记录

导入 CAR 文件时,请注意可能存在悬空的 CID 引用。例如,仓库可能包含指向其他仓库中的 blob 或记录的 CID Links,这些 blob 或引用对应的块可能不会包含在 CAR 文件中。

CARv1 规范对同一文件中出现多次相同块("重复块")持中立态度。实现应该对块的重复和去重都具有鲁棒性,也应该忽略任何不必要或未链接的块。

## 仓库差异

<Note>
同步协议的更新版本将在 2025 年初部署到实时网络。有一份["Sync v1.1"提案文档](https://github.com/bluesky-social/proposals/tree/main/0006-sync-iteration)和一篇[更新博客文章](https://docs.bsky.app/blog/relay-sync-updates)包含部署细节。书面规范将很快更新。
</Note>

支持独立服务之间数据高效同步的一个概念是不同修订版本之间的仓库树"差异"。基本原理是仓库差异包含一个较旧修订版本和当前修订版本之间已更改的所有数据(commit 对象、MST 节点和记录)。可以将差异"应用"到仓库的较旧镜像,结果将是当前(较新)commit 修订版本的完整 MST 树。

仓库差异可以序列化为 CAR 文件,有时称为"CAR slices"。关于差异 CAR slices 的一些细节:

- 与完整仓库导出 CAR 文件具有相同的格式、版本和 atproto 特定约束
  - 块"应该"按 CID 去重(只包含一个副本),尽管接收实现必须对重复具有弹性
- CAR 头中指示的根 CID(roots 的第一个元素)应指向 commit 块(必须包含)
- 即使所需块之前出现在仓库的历史记录中,也必须包含。例如,如果一个记录在修订版 C 中创建,在修订版 F 中删除,在修订版 N 中重新创建,则"自 F 以来"的差异必须包含记录块
- 必须包含所有"创建"的记录
- 已"删除"且在当前仓库中不存在的任何记录都不应包含
- 任何已"更新"的记录应包含最终版本,不应包含以前的版本
- 必须包含当前仓库中在前一个仓库版本中不存在的所有 MST 节点
- 除了移除的记录数据外,差异可能包含其他块,接收方应忽略这些块。
  - 但是,故意包含大量不相关块数据以消耗网络或计算资源的差异被视为一种网络滥用。

差异是一个包含已签名 commit 的部分 Merkle 树,可以部分验证。这意味着成功解析了相关账户身份(包括加密公钥)的观察者可以验证数据的某些方面。差异对于记录的创建和更新是可靠的"证明链":观察者可以验证新记录或更新的记录在 commit 修订版本的整体仓库中具有特定的记录值。如果观察者知道已删除的特定记录(通过仓库路径或完整的 AT-URI),他们可以验证这些记录在最终 commit 修订版本中不再存在。

然而,不知道"较旧"修订版本仓库完整状态的观察者*不能*可靠地枚举已从仓库中移除的所有记录。这样的观察者也无法看到已删除或更新的记录的以前值,无论是完整值还是通过 CID。注意,后者是差异概念的一个有意设计目标:希望内容删除快速发生,不"引起注意"到已删除的内容。技术上可以让"存档"观察者跟踪删除事件并查找以前的内容值,但这需要额外的资源和努力。

有时仓库差异是自动生成的。例如,对仓库的每次提交都可能导致与之前提交的差异。在其他情况下,差异是按需生成的:可以请求"自"任意先前修订版本的差异。不期望仓库主机支持在两个任意修订版本之间生成差异,只支持从任意较旧修订版本到当前修订版本的差异。仓库主机不需要维护先前提交/修订版本的完整历史记录,在某些情况下(如账户迁移)可能从未拥有过先前的仓库历史记录。关于如何解释和服务"自"先前修订版本以来的差异请求的一些细节:

- 在内部跟踪块(记录或 MST 节点)创建或重新创建时的 commit 修订版本是有帮助的。这使得查询"自"某个时间点以来的块成为可能
- "since"修订版本不需要完全匹配
  - 例如,如果一个仓库有一系列提交"333"、"666"、"999",并且请求了"自"444"以来的差异,应包括"666"和"999"中的更改,就像"since"参数是"666"一样
- 主机可以包含额外的历史记录,但鼓励返回最小或最细粒度的请求数据
  - 例如,主机可能已将仓库修订历史"压缩"为较少的提交。如果一个仓库有提交历史"288"、"300"、"320"、"340"、"400",并收到"自"340 以来的请求,它可能返回自 300 以来的所有更改。鼓励主机在可能时返回最小差异(例如,"自"340 以来),但客户端应具有弹性。
- 如果主机收到早于仓库可用最早修订版本的"since"请求,应返回完整仓库。如果主机没有仓库的完整历史记录,可能会发生这种情况。
  - 例如,如果一个仓库有修订版本"140"、"150"和"160",然后迁移到新的 PDS 并继续修订版本"161"和"170",如果新的 PDS 被要求提供"自"150 以来的差异,新的 PDS 可能需要返回完整仓库,因为它能感知到的最早修订版本是"160"或"161"(取决于迁移如何实现)。

在出现在 firehose 上的链式 commit-to-commit 差异的特定情况下,差异应该是"最小的":它们不应包含额外的记录或额外的历史记录。

## 安全考虑

仓库是不可信的输入:账户对仓库内容有完全控制权,PDS 实例对二进制编码有完全控制权。重要的是要处理来自敌对行为者或意外情况(如数据损坏或存在错误的实现)的潜在拒绝服务向量。

应遵循 CBOR 解码的通用预防措施:最大序列化对象大小、嵌套字段的最大递归深度、反序列化数据的最大内存预算等。一些 CBOR 库默认包含这些预防措施,但其他库则不包含。

MST 数据结构的效率取决于键哈希的相对随机分布。由于账户可以控制 Record Keys,它们可以挖掘具有特定深度和排序顺序的记录键集,这会导致低效的树形状,可能在联邦流的上下文中造成大量存储开销和网络放大。为防止这些攻击,实现应将每个节点的 TreeEntries 数量限制在统计上不太可能的最大长度。可能还需要限制仓库的总体深度或其他参数,以防止更复杂的键挖掘攻击。

导入 CAR 文件时,应验证仓库结构的完整性。CAR 结构中可能包含额外的不相关块;在将 CAR 内容直接注入到后端块存储时应小心,以确保不会在未引用的块上浪费资源。CAR 导入也可能存在跨账户污染问题,例如通过来自不相关账户的 CAR 导入重新出现之前删除的记录。


## 可能的未来变更

可能会实现一个可选的仓库内机制,用于存储同一记录(按路径)的多个版本。例如,添加额外的路径字段来通过 CID、时间戳或单调递增的版本整数指示版本。

正在考虑存储与每个记录相关的元数据的机制,例如通用标签、重用权限或 hashtag 元数据。这将允许在不修改记录本身的情况下更改元数据,并使某些元数据在词典之间通用。

仓库路径限制可能会以其他方式放宽,包括更少或更多的路径段、更多允许的字符(包括非 ASCII)等。路径将始终是有效的 Unicode 字符串,通过 UTF-8 编码映射到 MST 键(字节数组)。

在整体 atproto 规范级别,随着时间推移可能会添加额外的"blessed"加密算法。同样,可能会添加引用记录和 blob 的额外 CID 格式。内部 CID 格式更改需要仓库格式版本升级。

仓库 CAR 导出可能包括链接的"blob"(较大的二进制文件)。这可能成为默认设置,或可配置选项,或者可能选择其他 blob 导出机制(例如 `.tar` 或 `.zip` 导出)。

记录内容有一天可能不是 DAG-CBOR。这可能需要仓库格式版本升级。请注意,可以通过字节数组字段在 DAG-CBOR 包装器中高效地包装其他数据格式,或者有一个链接到任意格式 blob 的小型 DAG-CBOR 记录类型。

仓库 CAR 导出最终可能会指定首选的块排序方案。

在某种形式上可能会采用包含一些用例优化的 CARv2 文件格式。

向 commit 和 MST 节点对象添加可选字段可能导致或不导致仓库格式版本更改。更改 MST fanout 或对当前 MST 字段的任何更改都将是完整的仓库版本更改。

